<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0093)http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001060000000000000000 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Data types</title>
<meta name="description" content="Data types">
<meta name="keywords" content="schemetutorial">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">


<meta name="Generator" content="LaTeX2HTML v99.2beta6">
<meta http-equiv="Content-Style-Type" content="text/css">

<link rel="STYLESHEET" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.css">

<link rel="next" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">
<link rel="previous" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node9.html">
<link rel="up" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.html">
<link rel="next" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">
</head>

<body>
<!--Navigation Panel-->
<a name="tex2html298" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">
<img width="37" height="24" align="BOTTOM" border="0" alt="next" src="./Data types_files/next.png"></a> 
<a name="tex2html294" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.html">
<img width="26" height="24" align="BOTTOM" border="0" alt="up" src="./Data types_files/up.png"></a> 
<a name="tex2html288" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node9.html">
<img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="./Data types_files/prev.png"></a> 
<a name="tex2html296" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node1.html">
<img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="./Data types_files/contents.png"></a>  
<br>
<b> Next:</b> <a name="tex2html299" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">Equivalence predicates</a>
<b> Up:</b> <a name="tex2html295" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.html">Scheme Tutorial</a>
<b> Previous:</b> <a name="tex2html289" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node9.html">Imperative programming</a>
 &nbsp; <b>  <a name="tex2html297" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node1.html">Contents</a></b> 
<br>
<br>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<a name="CHILD_LINKS"><strong>Subsections</strong></a>

<ul>
<li><a name="tex2html300" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001010000000000000000">Numbers</a>
<ul>
<li><a name="tex2html301" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001011000000000000000">Operations on numbers</a>
</li></ul>
</li><li><a name="tex2html302" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001020000000000000000">Booleans</a>
<ul>
<li><a name="tex2html303" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001021000000000000000">Operations on booleans</a>
</li></ul>
</li><li><a name="tex2html304" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001030000000000000000">Characters</a>
<ul>
<li><a name="tex2html305" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001031000000000000000">Operations on characters</a>
</li></ul>
</li><li><a name="tex2html306" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001040000000000000000">Symbols</a>
<ul>
<li><a name="tex2html307" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001041000000000000000">Operations on symbols</a>
</li></ul>
</li><li><a name="tex2html308" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001050000000000000000">Strings</a>
<ul>
<li><a name="tex2html309" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001051000000000000000">Operations on strings</a>
</li></ul>
</li><li><a name="tex2html310" href="./Data types_files/Data types.html">Pairs and lists</a>
<ul>
<li><a name="tex2html311" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001061000000000000000">Pairs</a>
</li><li><a name="tex2html312" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001062000000000000000">Lists</a>
</li><li><a name="tex2html313" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001063000000000000000">Operations on pairs and lists</a>
</li></ul>
</li><li><a name="tex2html314" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001070000000000000000">Vectors</a>
<ul>
<li><a name="tex2html315" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node10.html#SECTION001071000000000000000">Operations on vectors</a>
</li></ul></li></ul>
<!--End of Table of Child-Links-->
<hr>

<h1><a name="SECTION001000000000000000000">
Data types</a>
</h1>

<p>

</p><h1><a name="SECTION001010000000000000000">
Numbers</a>
</h1>

<p>
Numbers can be arranged in different subtypes, e.g.

</p><ul>
<li>number
</li>
<li>complex
</li>
<li>real
</li>
<li>rational
</li>
<li>integer
</li>
</ul>

<p>
For example, 2 is an integer, but it is also a rational, a real and a 
complex number.

</p><p>
Numbers can be represented both exactly and inexactly. A number is exact if
it was written as an exact constant or was derived from exact numbers using
only exact operations. Otherwise the number is inexact. The procedure
<tt>inexact-&gt;exact</tt> is an exception to this rule. 

</p><p>
A number may be expressed in binary, octal, decimal or hexadecimal by the
use of a radix prefix: <tt>#b</tt> for binary, <tt>#o</tt> for octal, 
<tt>#d</tt> for decimal and <tt>#x</tt> for hexadecimal. If no prefix is 
specified the radix is in decimal by default.

</p><p>

</p><h2><a name="SECTION001011000000000000000">
Operations on numbers</a>
</h2>
Scheme provides the following predicates for numbers:
<pre>(number? x)
(complex? x)
(real? x)
(rational? x)
(integer? x)
(exact? x)
(inexact? x)
(zero? x)
(positive? x)
(negative? x)
(even? x)
(odd? x)
</pre>

<p>
The names clearly imply what the procedures do, so we will only take a look
at some examples:
</p><pre>&gt; (number? 5)
#t
&gt; (complex? 5)
#t
&gt; (zero? 0)
#t
&gt; (even? 0)
#t
&gt; (odd? 10)
#f
&gt; (exact? (* 5 5))
#t
&gt;(inexact? 3.1415)
#t
</pre>

<p>
Arithmetic operations can be performed with the corresponding operators,
for example:
</p><pre>&gt; (+ 2 3 4)
9
&gt; (- 5 6)
-1
&gt; (* 1 2)
2
&gt; (/ 1 2)
1/2
&gt; (/ 1 2.0)
0.5
&gt; (+ (* 3 4) 2)
14
</pre>

<p>
<tt>+</tt>, <tt>-</tt> and <tt>*</tt> are guaranteed to return exact results
if the arguments are exact. Some implementations regard division as an exact
operation if the arguments are exact. However, if division is performed on
exact numbers, which are very large, the computation might become very slow.
In that case one argument should be given as an inexact number, because it will
speed up the computation, but the result will no longer be exact. Unless
exact numbers are required this should not be a problem. Inexact numbers can
also be converted into exact numbers with the procedure 
<tt>inexact-&gt;exact</tt>.

</p><p>
There are also a couple of procedures which test whether their arguments are
equal, monotonically increasing or decreasing or monotonically nonincreasing
or decreasing. These are:
</p><pre>(= x1 x2 ...)
(&gt; x1 x2 ...)
(&lt; x1 x2 ...)
(&gt;= x1 x2 ...)
(&lt;= x1 x2 ...)
</pre>

<p>
They return either <tt>#t</tt> or <tt><tt>#f</tt></tt>. 
For example:
</p><pre>&gt; (&lt; 3 4 5 6)
#t
&gt; (&lt;= 3 4 5 6)
#t
&gt; (&gt; 4 2 3 6)
#f
</pre>

<p>
Note that <tt>=</tt> should only be used with exact numbers even if it
isn't  an error to use it on inexact ones<a name="tex2html15" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/footnode.html#foot1554"><sup>8.1</sup></a>. If used on inexact numbers, it might  return
something  unexpected because of the representation of inexact numbers
in the machine.

</p><p>
Scheme also provides various mathematical procedures:
</p><pre>(abs x)              ; returns the absolute value of x
(acos x)             ; returns the arccosine of x
(asin x)             ; returns the arcsine of x
(atan x)             ; returns the arctangent of x
(atan x1 x2)         ; computes (angle (make-rectangular x2 x1))
(ceiling x)          ; rounds x upwards
(cos x)              ; returns the cosine of x
(denominator x)      ; returns the denominator of x
(exp x)              ; returns e^x
(expt n k)           ; returns n^k		
(floor x)            ; rounds x downwards
(gcd x1 x2 ...)      ; computes the greatest common divisor
(lcm x1 x2 ...)      ; computes the least common multiple
(log x)              ; returns the natural logarithm of x 
(max x1 x2 ...)      ; returns the largest of the arguments
(min x1 x2 ...)      ; returns the smallest of the arguments
(modulo x1 x2)       ; computes the modulo of the arguments
(numerator x)        ; returns the numerator of the argument
(quotient x1 x2)     ; returns the quotient of the arguments
(rationalize x1 x2)  ; returns the simplest rational number differing
                     ; from x1 no more than x2
(remainder x1 x2)    ; returns the remainder of the arguments
(round x)            ; rounds the argument (see the example below)
(sin x)              ; returns the sine of x
(sqrt x)             ; returns the square root of x
(tan x)              ; returns the tangent of x
(truncate x)         ; truncates x
</pre>

<p>
For example, we can define <img width="14" height="14" align="BOTTOM" border="0" src="./Data types_files/img6.png" alt="pi"> by using the mathematical procedure 
<tt>acos</tt> in the following way:
</p><pre>&gt; (define pi (acos -1))
&gt; pi
3.1415926535898
</pre>

<p>
As can be seen from the list above, there are four procedures for rounding
numbers. 

</p><p>
The procedure <tt>round</tt> rounds the argument to the nearest 
integer, but if the arguments is halfway between two integers, it rounds it
to the nearest even integer. For example:
</p><pre>&gt; (round pi)
3.0
&gt; (round 3.5)
4.0
&gt; (round 2.5) 
2.0
&gt; (round -2.5)
-2.0
&gt; (round -3.4)
-3.0
&gt; (round -3.5)
-4.0
</pre>

<p>
The procedure <tt>truncate</tt> chops the decimal part of the argument:

</p><p>
</p><pre>&gt; (truncate pi)
3.0
&gt; (truncate 3.5)
3.0
&gt; (truncate -3.5)
-3.0
</pre>

<p>
The procedure <tt>ceiling</tt> returns the smallest integer which is greater
than or equal to the argument, for example:

</p><p>
</p><pre>&gt; (ceiling pi)
4.0
&gt; (ceiling 3.5)
4.0
&gt; (ceiling -3.5)
-3.0
</pre>

<p>
The procedure <tt>floor</tt> returns the largest integer which is less than
or equal to the argument, for example:
</p><pre>&gt; (floor pi)
3.0
&gt; (floor 3.5)
3.0
&gt; (floor -3.5)
-4.0
</pre>

<p>
Scheme also provides some trigonometric functions. Note that the argument is
in radians. For example:

</p><p>
</p><pre>&gt; (sin pi)
0.0
&gt; (cos pi)
-1.0
&gt; (- (tan pi) (/ (sin pi) (cos pi)))
0.0
&gt; (sqrt (ceiling (abs (cos pi))))
1.0
</pre>

<p>
Some general procedures for complex numbers are also provided:
</p><pre>(make-rectangular x1 x2)   ; constructs a complex number in rectangular form
(make-polar x1 x2)         ; constructs a complex number in polar form
(real-part z)              ; returns the real part of the complex number z
(imag-part z)              ; returns the imaginary part of the complex number z
(magnitude z)              ; returns the magnitude of the complex number z
(angle z)                  ; returns the angle of the complex number z
</pre>

<p>
For example, 
</p><pre>&gt; (define a (make-rectangular 3 4))
&gt; a
3+4i
&gt; (real-part a)
3
&gt; (imag-part a)
4
&gt; (magnitude a)
5
&gt; (angle (make-rectangular 3 4))
0.92729521800161
</pre>

<p>
Scheme also provides the procedures <tt>inexact-&gt;exact</tt> and 
<tt>exact-&gt;inexact</tt> for converting inexact numbers into exact and vice
versa, for example:
</p><pre>&gt; (inexact-&gt;exact 5.0)
5
&gt; (exact-&gt;inexact 5)
5.0
</pre>

<p>

</p><h1><a name="SECTION001020000000000000000">
Booleans</a>
</h1>

<p>
The boolean objects are true and false and are written as <tt>#t</tt> and <tt>#f</tt>. 
All standard values in Scheme except <tt>#f</tt> count as true in conditional 
expressions.

</p><p>
Boolean constants evaluate to themselves and need not be quoted in
programs, e.g.
</p><pre>&gt; #f
#f
&gt; #t
#t
</pre>

<p>

</p><h2><a name="SECTION001021000000000000000">
Operations on booleans</a>
</h2>

<p>
Scheme provides a predicate <tt>boolean?</tt> with the following syntax:
</p><pre>(boolean? x)
</pre>

<p>
If <i>x</i> is either <tt>#t</tt> or <tt>#f</tt>, then <tt>#t</tt> is returned, otherwise <tt>#f</tt> is
returned.

</p><p>
</p><pre>&gt; (boolean? #t) 
#t
&gt; (boolean? '())
#f
&gt; (boolean? (eq? 'x '(x y z)))
#t
</pre>

<p>
Another procedure is <tt>not</tt>, which takes one argument and negates it:
</p><pre>&gt; (not #f)
#t
&gt; (not (= 5 4))
#t
</pre>

<p>
Also the special forms <tt>and</tt> and <tt>or</tt> are used on boolean 
expressions.

</p><p>

</p><h1><a name="SECTION001030000000000000000">
Characters</a>
</h1>

<p>
Characters are letters, numbers and other symbols on the computer
keyboard as well as some control characters such as <i>newline</i>
and
<i>space</i>. Characters are written using the notation 
<tt>#\&lt;char&gt;</tt> 
or <tt>#\&lt;character name&gt;</tt>. The former is case
sensitive whereas the  latter is not.

</p><p>
Example:
</p><pre>#\space
#\newline
#\s
</pre>

<p>
Characters written in the #\ notation are self-evaluating.

</p><p>

</p><h2><a name="SECTION001031000000000000000">
Operations on characters</a>
</h2>

<p>
Most of the procedures for characters are predicates. If the procedure ignores
case it usually has <i>-ci</i> embedded in its name.

</p><p>
Scheme provides the procedure <tt>char?</tt>, which has the following syntax:
</p><pre>(char? x)
</pre>

<p>
If <i>x</i> is a character, the procedure returns <tt>#t</tt>, otherwise it 
returns <tt>#f</tt>. For example:
</p><pre>&gt; (char? #\a)
#t
&gt; (char? 'a)   ;; 'a is a symbol, not a character
#f
&gt; (char? "a")  ;; "a" is a string, not a character
#f
&gt; (char? #\space)
#t
</pre>

<p>
There are also procedures for finding out whether a given character comes
before or after another character in the alphabet. These are
</p><pre>(char=? ch1 ch2)     ; Is ch1 the same character as ch2?
(char&lt;? ch1 ch2)     ; Does ch1 come before ch2 in the alphabet?
(char&gt;? ch1 ch2)     ; Does ch1 come after ch2 in the alphabet?
(char&lt;=? ch1 ch2)    ; Does ch1 come before ch2 or are they both the same?
(char&gt;=? ch1 ch2)    ; Does ch1 come after ch2 or are they both the same?
(char-ci=? ch1 ch2)  ; The same as char=? but case-insensitive
(char-ci&lt;? ch1 ch2)  ; The same as char&lt;? but case-insensitive
(char-ci&gt;? ch1 ch2)  ; The same as char&gt;? but case-insensitive
(char-ci&lt;=? ch1 ch2) ; The same as char&lt;=? but case-insensitive
(char-ci&gt;=? ch1 ch2) ; The same as char&gt;=? but case-insensitive
</pre>

<p>
Note that the lower case letters are in order, the upper case letters
are in order and the digits are in order and that all the upper case
letters precede  all the lower case or vice versa. Also note that all the 
digits either precede all the upper case letters or vice versa and that all the
digits either precede all the lower case letters or vice versa.

</p><p>
The following example shows the use of the procedures mentioned above, but
the result returned of the last expression is implementation-dependent:

</p><p>
</p><pre>&gt; (char=? #\a #\A)
#f
&gt; (char-ci=? #\a #\A)
#t
&gt; (char&lt;? #\a #\b)
#t
&gt; (char&gt;? #\a #\A)
#t
</pre>

<p>
Scheme also provides procedures for finding out what kind of character is in
question, e.g. is it a digit, an alphabetic character...These procedures 
are:
</p><pre>(char-alphabetic? ch)
(char-numeric? ch)
(char-whitespace? ch)
(char-upper-case? ch)
(char-lower-case? ch)
</pre>

<p>
Space, tab, line feed, form feed and carriage return are all regarded as 
whitespace characters.

</p><p>
For example:
</p><pre>&gt; (char-alphabetic? #\a)
#t
&gt; (char-numeric? #\a)
#f
&gt; (char-numeric? #\2)
#t
&gt; (char-upper-case? #\A)
#t
&gt; (char-lower-case? #\A)
#f
</pre>

<p>
There are also procedures for converting characters to integers representing 
the character (e.g. in the ASCII character set) and vice versa. 
These procedures are <tt>char-&gt;integer</tt> and <tt>integer-&gt;char</tt> and 
have the following syntax:
</p><pre>(char-&gt;integer ch)
(integer-&gt;char n)
</pre>

<p>
and can be used for example in the following way:
</p><pre>&gt; (char-&gt;integer #\3)
51
&gt; (char-&gt;integer #\a)
97
&gt; (integer-&gt;char 56)
#\8
&gt; (integer-&gt;char (char-&gt;integer #\b))
#\b
</pre>

<p>
Note that the result returned by these procedures are implementation dependent.

</p><p>
Scheme also provides two procedures for converting upper case characters to
lower case and vice versa. They are the following:
</p><pre>(char-upcase ch)
(char-downcase ch)
</pre>

<p>
For example:
</p><pre>&gt; (char-upcase #\a)
#\A
&gt; (char-downcase #\B)
#\b
&gt; (char-downcase #\b)
#\b
&gt; (char-downcase (char-upcase #\c))
#\c
</pre>

<p>

</p><h1><a name="SECTION001040000000000000000">
Symbols</a>
</h1>

<p>
Symbols are objects, whose usefulness rest on the fact that two symbols are
equal if and only if their names are spelled the same way. 

</p><p>

</p><h2><a name="SECTION001041000000000000000">
Operations on symbols</a>
</h2>

<p>
Scheme provides a predicate <tt>symbol?</tt>, which takes one argument and
returns <tt>#t</tt> if the argument was a symbol and <tt>#f</tt> otherwise. For example,
</p><pre>&gt; (symbol? 'boo)
#t
&gt; (symbol? "boo")
#f
&gt; (symbol? (car '(a b c)))
#t
&gt; (symbol? '())
#f
</pre>

<p>
There are also two procedures for converting a symbol to a string and vice 
versa, namely the procedures <tt>symbol-&gt;string</tt> and 
<tt>string-&gt;symbol</tt>. Note that the strings returned by
<tt>symbol-&gt;string</tt> are immutable.

</p><p>
The procedures <tt>symbol-&gt;string</tt> and <tt>string-&gt;symbol</tt> work in the 
following way:
</p><pre>&gt; (symbol-&gt;string 'foo)
"foo"
&gt; (string-&gt;symbol "foo")
foo
&gt; (symbol-&gt;string (string-&gt;symbol "bar"))
"bar"
</pre>

<p>

</p><h1><a name="SECTION001050000000000000000">
Strings</a>
</h1>

<p>
A string is written as a sequence of characters enclosed in double quotes. The
length of the string is the number of characters it contains. The first
character has the index value zero. Doublequotes can be written inside a
string by escaping them with a backslash.

</p><p>
Example:
</p><pre>"This is a string and \"this is a string\" is also a string."
</pre>

<p>

</p><h2><a name="SECTION001051000000000000000">
Operations on strings</a>
</h2>

<p>
Scheme provides a predicate <tt>string?</tt> for testing whether a given 
object is a string. It has the following syntax:
</p><pre>(string? str)
</pre>

<p>
If <i>str</i> is a string, <tt>#t</tt> is returned, otherwise <tt>#f</tt> is returned.
For example,
</p><pre>&gt; (string? "boo")    
#t
&gt; (string? 'boo)    ; false, because 'boo is a symbol
#f
&gt; (string? 5)       ; false, because 5 is a number
#f
&gt; (string? "")
#t
</pre>

<p>
Scheme also provides a variety of predicates for determining the 
lexicographic order of two strings.  If two strings differ in length in such 
a way that one is the prefix of the  other, the shorter  string is considered 
to be lexicographically less than the other. The procedures can be regarded as
extensions to strings of the corresponding orderings of characters.

</p><p>
The predicates are the following:
</p><pre>(string=? str1 str2)     ; Is str1 the same as str2?   
(string&lt;? str1 str2)     ; Is str1 lexicographically less than str2?
(string&gt;? str1 str2)     ; Is str2 lexicographically less than str1?
(string&lt;=? str1 str2)    ; Is str1 lexicographically less than or equal to str2?
(string&gt;=? str1 str2)    ; Is str2 lexicographically less than or equal to str1?
(string-ci=? str1 str2)  ; The same as string=? but case-insensitive
(string-ci&lt;? str1 str2)  ; The same as string&lt;? but case-insensitive 
(string-ci&gt;? str1 str2)  ; The same as string&gt;? but case-insensitive
(string-ci&lt;=? str1 str2) ; The same as string&lt;=? but case-insensitive
(string-ci&gt;=? str1 str2) ; The same as string&gt;=? but case-insensitive
</pre>

<p>
The procedures containing <i>-ci</i> are case-insensitive. For example:
</p><pre>&gt; (string=? "foo" "FOO")      ; false, considered as different strings
#f
&gt; (string-ci=? "foo" "FOO")   ; true, the procedure is case-insensitive
#t
&gt; (string&lt;? "bar" "foo")      ; true, since bar comes before foo
#t
&gt; (string&lt;? "foobar" "foo")   ; false, foo is a prefix of and "less than" foobar
#f
</pre>

<p>
Scheme also provides various procedures for creating and manipulating strings.
Strings can be created with the procedures <tt>make-string</tt> and 
<tt>string</tt>. They have the following syntax:
</p><pre>(make-string n)
(make-string n ch)
(string ch1 ch2 ...)
</pre>

<p>
It is also possible to create a string using doublequotes. Such strings are
so called string constants and cannot be changed later with procedures such
as <tt>string-set!</tt>. For example:
</p><pre>&gt; "foo"
"foo"
</pre>

<p>
Even if some implementations allow changing constant strings, you should not be
tempted to do so!

</p><p>
The procedure <tt>make-string</tt> takes either one or two arguments, where
<i>n</i> is the number of characters and <i>ch</i> represents the 
character. If <i>ch</i> is given, all characters in the string will be 
initialied to <i>ch</i>, otherwise the contents of the string are
implementation-dependent. The procedure <tt>string</tt> takes an arbitrary
number of characters and returns a string composed of the given characters.
For example:
</p><pre>&gt; (make-string 10 #\a)
"aaaaaaaaaa"
&gt; (string #\S #\c #\h #\e #\m #\e)
"Scheme"
</pre>

<p>
The length of the string is the number of characters it is composed of. The
length of the empty string is 0. Scheme provides a procedure for computing the
length of the string, namely <tt>string-length</tt>, which takes one string as
an argument and returns an integer. For example:
</p><pre>&gt; (string-length "Scheme")
6
&gt; (string-length "This is a very clever sentence")
30
&gt; (string-length "")
0
</pre>

<p>
Strings can also be concatenated using <tt>string-append</tt>, which takes
an arbitrary number of arguments and returns a newly allocated string 
composed of the characters of the strings given as arguments. For example:
</p><pre>&gt; (string-append "foo" "bar" "foo" "bar" "foobar")
"foobarfoobarfoobar"
&gt; (string-append "Hello!" " " "My name is Torsten")
"Hello! My name is Torsten"
&gt; (string-append)
""
</pre>

<p>
It is also possible to extract characters from a string using the 
<tt>string-ref</tt> procedure, which takes a string and an integer <i>n</i>
and returns the <i>n</i>th character. Note that the first character has the
index 0. For example:
</p><pre>&gt; (string-ref "foobar" 0)
#\f
&gt; (string-ref "foobar" 1)
#\o
&gt; (string-ref "foobar" 10)
string-ref: index 10 out of range [0, 5] for string: "foobar"
</pre>

<p>
Scheme also provides a procedure <tt>substring</tt> with the following syntax:
</p><pre>(substring str start end)
</pre>

<p>
<i>str</i> must be a string and <i>start</i> and <i>end</i> are integers
such that 

<br><!-- MATH
 $0~\le~start~\le~end~\le~$
 -->
<img width="168" height="29" align="MIDDLE" border="0" src="./Data types_files/img8.png" alt="0 &lt;= start &lt;= end &lt;="> the length of the string.

</p><p>
For example:
</p><pre>&gt; (substring "foobar" 1 3)
"oo"
&gt; (substring "foobar" 0 0)
""
</pre>

<p>
Scheme provides procedures for converting strings to lists of characters and 
vice versa. These
are <tt>string-&gt;list</tt> and <tt>list-&gt;string</tt> and work in the following
way:
</p><pre>&gt; (string-&gt;list "foobar")
(#\f #\o #\o #\b #\a #\r)
&gt; (list-&gt;string '(#\f #\o #\o #\space #\b #\a #\r))
"foo bar"
&gt; (list-&gt;string '())
""
&gt; (string-&gt;list "")
()
</pre>

<p>
Strings can be copied with the <tt>string-copy</tt> procedure, which takes
a string to be copied as argument and returns a newly allocated copy of the
argument. For example:
</p><pre>&gt; (string-copy "foobar")
"foobar"
&gt; (define a "foobar")
&gt; (define b (string-copy a))
&gt; b
"foobar"
</pre>

<p>
There are two procedures causing side effects, namely <tt>string-set!</tt> and
<tt>string-fill!</tt>. The procedure <tt>string-set!</tt> has the following
syntax:
</p><pre>(string-set! str n ch)
</pre>

<p>
and stores <i>ch</i> in element <i>n</i> of <i>str</i>. The value 
returned is unspecified. 

</p><p>
For example:
</p><pre>&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; str
"foobar"
&gt; (string-set! str 2 #\d)
&gt; str
"fodbar"
&gt; (string-set! str 0 #\b)
&gt; str
"bodbar"
</pre>

<p>
The procedures <tt>string-set!</tt> and <tt>string-copy</tt> are often used
together. We might, for example, want a copy of a given string, which we want
to change without changing the original string:
</p><pre>&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; (define foo (string-copy str))
&gt; str
"foobar"
&gt; foo
"foobar"
&gt; (string-set! foo 0 #\g)
&gt; str
"foobar"
&gt; foo
"goobar"
</pre>

<p>
The procedure <tt>string-fill!</tt> has the following syntax:
</p><pre>(string-fill! str ch)
</pre>

<p>
and stores <i>ch</i> in every element of <i>str</i> as a side effect. The
return value is unspecified. 

</p><p>
For example:
</p><pre>&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; (string-fill! str #\a)
&gt; str
"aaaaaa"
</pre>

<p>

</p><h1><a name="SECTION001060000000000000000">
Pairs and lists</a>
</h1>

<p>

</p><h2><a name="SECTION001061000000000000000">
Pairs</a>
</h2>
A pair is a compound structure that can be manipulated and given a 
name. It is created using the procedure <tt>cons</tt>, which takes two
arguments and returns a compound data object containing the two arguments.
These can be extracted with the procedures <tt>car</tt> and <tt>cdr</tt>.

<p>
For example:
</p><pre>(cons 1 2)
</pre>

<p>
constructs a pair consisting of the two integers 1 and 2. The external
representation of this pair is <tt>(1 . 2)</tt>.  If we wish to give
our compound data object a name, we can use <tt>define</tt> as we are
used to:

</p><p>
</p><pre>(define a (cons 1 2))
</pre>

<p>
If we wish to extract the first integer in the pair, we use <tt>car</tt>
</p><pre>&gt;(car a)
1
</pre>

<p>
and if we wish to extract the second integer, we use <tt>cdr</tt>:

</p><p>
</p><pre>&gt;(cdr a)
2
</pre>

<p>

</p><h2><a name="SECTION001062000000000000000"></a>
<a name="ls"></a>
<br>
Lists
</h2>
Lists can be built using pairs. A list is denoted by a collection of items
enclosed in parentheses, e.g.
<pre>(2 4 6 8 10)
</pre>

<p>
In other words, a list is a chain of pairs ending in the empty list.
If the chain of pairs does not end with the empty list, the list is said to
be improper. An improper list is not a list!

</p><p>
The empty list is denoted <tt>()</tt>. The list <tt>(2 4 6 8 10)</tt>
is the  same as <tt>(2 . (4 . (6 . (8 . (10 . ())))))</tt>. An
improper list can be  represented using dotted notations in the
following way:
<tt>(2 4 6 8 . 10)</tt>, which is equivalent to 
<tt>(2 . (4 . (6 . (8 . 10))))</tt>. 

</p><p>
Note that lists should be quoted when fed to the interpreter,
otherwise the  interpreter will try to apply the first item in the
list to the other items  in the list, e.g.
</p><pre>&gt; (2 4 6 8)
procedure application: expected procedure, given: 2; arguments were: 4 6 8
&gt; '(2 4 6 8)
(2 4 6 8)
</pre>

<p>
Lists can be constructed using <tt>cons</tt> in the following way:
</p><pre>(cons 2 (cons 4 (cons 6 (cons 8 (cons 10 '())))))
</pre>

<p>
Note that 
</p><pre>(cons 1 (cons 2 '()))
</pre>

<p>
is a list, whereas
</p><pre>(cons 1 2)
</pre>

<p>
is not. The latter is a pair. A list is constructed from pairs and is
consiedered a pair, but a pair is not in itself a list! The empty list is,
however, not a pair.

</p><p>
Lists can also be constructed using the procedure <tt>list</tt> as follows:
</p><pre>(list 2 4 6 8 10)
</pre>

<p>
If we wish to take lists apart, we can use <tt>car</tt> and <tt>cdr</tt> and
combinations thereof. For example:
</p><pre>&gt;(car (list 2 4 6 8 10))
2
</pre>

<p>
whereas  

</p><p>
</p><pre>&gt;(cdr (list 2 4 6 8 10))
(4 6 8 10)
</pre>

<p>
The result of applying <tt>cdr</tt> to a list is always a list.

</p><p>
Let's say that we want to extract the second element in
the list. In order to accomplish this we can combine <tt>car</tt> and 
<tt>cdr</tt> in the following way:

</p><p>
</p><pre>&gt;(car (cdr (list 2 4 6 8 10)))
4
</pre>

<p>
There is a shortening for combined <tt>car</tt>:s and <tt>cdr</tt>:s. The
same could be accomplished as follows:
</p><pre>&gt;(cadr (list 2 4 6 8 10))
4
</pre>

<p>
<tt>car</tt>:s and <tt>cdr</tt>:s can be combined four times. Hence, the
following combinations exist:
</p><pre>(caar ls)        ; is the same as (car (car ls))
(cadr ls)        ; is the same as (car (cdr ls))
(cdar ls)        ; is the same as (cdr (car ls)) 
(cddr ls)        ; is the same as (cdr (cdr ls)) 
(caaar ls)       ; is the same as (car (car (car ls)))
(caadr ls)       ; is the same as (car (car (cdr ls))) 
(cadar ls)       ; is the same as (car (cdr (car ls))) 
(caddr ls)       ; is the same as (car (cdr (cdr ls))) 
(cdaar ls)       ; is the same as (cdr (car (car ls))) 
(cdadr ls)       ; is the same as (cdr (car (cdr ls)))
(cddar ls)       ; is the same as (cdr (cdr (car ls)))
(cdddr ls)       ; is the same as (cdr (cdr (cdr ls)))
(caaaar ls)      ; is the same as (car (car (car (car ls))))
(caaadr ls)      ; is the same as (car (car (car (cdr ls)))) 
(caadar ls)      ; is the same as (car (car (cdr (car ls))))
(caaddr ls)      ; is the same as (car (car (cdr (cdr ls))))
(cadaar ls)      ; is the same as (car (cdr (car (car ls)))) 
(cadadr ls)      ; is the same as (car (cdr (car (cdr ls))))
(caddar ls)      ; is the same as (car (cdr (cdr (car ls))))
(cadddr ls)      ; is the same as (car (cdr (cdr (cdr ls))))
(cdaaar ls)      ; is the same as (cdr (car (car (car ls))))
(cdaadr ls)      ; is the same as (cdr (car (car (cdr ls)))) 
(cdadar ls)      ; is the same as (cdr (car (cdr (car ls))))
(cdaddr ls)      ; is the same as (cdr (car (cdr (cdr ls))))
(cddaar ls)      ; is the same as (cdr (cdr (car (car ls))))
(cddadr ls)      ; is the same as (cdr (cdr (car (cdr ls))))
(cdddar ls)      ; is the same as (cdr (cdr (cdr (car ls))))
(cddddr ls)      ; is the same as (cdr (cdr (cdr (cdr ls))))
</pre>

<p>
For example:
</p><pre>&gt;(caddr (list 2 4 6 8 10))
6
&gt;(car (cdr (cdr (list 2 4 6 8 10))))
6
</pre>

<p>
These procedures can also be combined if the standards ones are insufficient.
For example:
</p><pre>&gt; (define ls '(((((((1 2) 3) 4) 5) 6) 7) 8))
&gt; (caaaar ls)
(((1 2) 3) 4)
&gt; (car (caaaar ls))
((1 2) 3)
&gt; (cdaar (caaaar ls))
(2)
</pre>

<p>
Scheme also provides the procedures <tt>set-car!</tt> and <tt>set-cdr!</tt>
for explicitly changing the value of the <tt>car</tt> or <tt>cdr</tt> of a 
list. This is done as a side effect and the return value is unspecified.

</p><p>
</p><pre>&gt; (define ls (list 1 2 3 4 5))
&gt; ls
(1 2 3 4 5)
&gt; (set-car! ls 10)
&gt; ls
(10 2 3 4 5)
&gt; (set-cdr! ls '())
&gt; ls
(10)
</pre>

<p>
Note that lists created in the following way cannot be changed using
<tt>set-car!</tt> or <tt>set-cdr!</tt>:
</p><pre>&gt; (define ls '(1 2 3 4 5))
</pre>

<p>
This is because <i>ls</i> is now a list constant that cannot be changed. 
Don't be tempted to do it incorrectly even if the implementation allows it.

</p><p>
Care should be taken when using <tt>set-car!</tt> and <tt>set-cdr!</tt>. For
example: when using <tt>set-cdr!</tt>, we may run into situations in which the
object is a list at first, but after application of <tt>set-cdr!</tt> it is
not. 

</p><p>

</p><h2><a name="SECTION001063000000000000000"></a>
<a name="opl"></a>
<br>
Operations on pairs and lists
</h2>
We have already seen both <tt>car</tt> and <tt>cdr</tt>, now we shall take
a look at some other procedures which operate on lists. 

<p>
The length of a list is the number of top-level items in it. Scheme provides a
procedure <tt>length</tt> for computing the length of the list, which is given
as an argument. For example:
</p><pre>&gt;(length (list 2 4 6 8 10))
5
</pre>

<p>
The length of the empty list is 0.
</p><pre>&gt; (length '())
0
</pre>

<p>
There are a couple of predicates for pairs and lists, namely 
<tt>pair?</tt>, <tt>list?</tt> and <tt>null?</tt>. They have the following
syntax:
</p><pre>(pair? x)
(list? x)
(null? x)
</pre>

<p>
The predicate <tt>pair?</tt> returns <tt>#t</tt> if <i>x</i> is a pair, otherwise it
returns <tt>#f</tt>. The predicate <tt>list?</tt> returns <tt>#t</tt> if <i>x</i> is a 
proper list and  <tt>#f</tt> otherwise. The predicate <tt>null?</tt> returns <tt>#t</tt> if 
<i>x</i> is the empty list and <tt>#f</tt> otherwise. 

</p><p>
</p><pre>&gt; (pair? (list 1 2 3 4))
#t
&gt; (pair? (cons 1 2))
#t
&gt; (pair? '())
#f
&gt; (pair? (car '(1 2 3)))
#f
&gt; (pair? (cdr '(1 2 3)))
#t
&gt; (pair? (car '((1 2) 3 4)))
#t
&gt; (pair? (cdr '(1 2)))
#t
</pre>

<p>
The first example is considered a pair, since a list is a chain of pairs 
ending in the empty list. The second example is naturally a pair, but the
third one, namely the empty list, is not a pair. Numbers are not pairs either,
so if the <tt>car</tt> of the list whose first item is not a pair or a list
is tested using <tt>pair?</tt>, then <tt>#f</tt> will be returned. If the 
first element, on the other hand, is a pair or a list,
then <tt>#t</tt> will be returned. One might wonder, why the procedure in the 
last example returns <tt>#t</tt> instead of <tt>#f</tt>. This is because 
<tt>(1&nbsp;2)</tt> is a list and lists always end with the empty list, so the 
<tt>cdr</tt> of <tt>(1 2)</tt> is not 2, but <tt>(2)</tt>!

</p><p>
</p><pre>&gt; (list? (list 1 2 3 4))
#t
&gt; (list? (cons 1 2))
#f
&gt; (list? (cons 1 (cons 2 '())))
#t
&gt; (list? '())
#t
&gt; (list? '(a . b))
#f
</pre>

<p>
The first example is obviously a list, but  the second is not, since a pair is
not a list. Lists end in the empty list, so the third example is a list. Also
the empty list alone is a list. The last example yields false, because the
list '(a . b) is not a proper list.

</p><p>
The predicate <tt>null?</tt> can be used as follows: 
</p><pre>&gt; (null? '(1 2 3))
#f
&gt; (null? '())
#t
&gt; (null? #f)
#f
</pre>

<p>
If we wish to address a given element in a list we might want to
use <tt>list-ref</tt>, which takes two arguments, a list <i>ls</i> and 
an integer <i>n</i> and returns the <i>n</i>:th item in <i>ls</i>. 
For example:
</p><pre>&gt;(list-ref '(1 2 3 4) 2)
3 
&gt; (list-ref '(1 2 3 4) 0)
1
&gt; (list-ref '(1 2 3 4) 5)
list-ref: index 5 too large for list: (1 2 3 4)
</pre>

<p>
Note that the index of the first item is 0! It is illegal to try to reference
an item with an index number larger than or equal to the length of the list.

</p><p>
If we want to return the sublist of a given list by omitting the first 
<i>n</i> items, we may use the procedure <tt>list-tail</tt>, which takes
two arguments, a list and an integer <i>n</i> as follows:
</p><pre>&gt; (list-tail '(1 2 3 4 5) 2)
(3 4 5)
&gt; (list-tail '(1 2 3 4 5) 0)
(1 2 3 4 5)
&gt; (list-tail '(1 2 3 4 5) 5)
()
&gt; (list-tail '(1 2 3 4 5) 7)
list-tail: index 7 too large for list: (1 2 3 4 5)
</pre>

<p>
As we can see, it is an error if <i>n</i> is larger than the length of the
list.

</p><p>
To reverse the order of items in a list we can use the procedure 
<tt>reverse</tt> as follows:
</p><pre>&gt;(reverse '(1 2 3 4))
(4 3 2 1)
&gt; (reverse '((1 2) (3 4) (5 6)))
((5 6) (3 4) (1 2))
</pre>

<p>
Scheme also provides a procedure <tt>append</tt> for appending lists, which 
are given as arguments: 
</p><pre>&gt; (append '(1 2 3) '(4 5 6))
(1 2 3 4 5 6)
&gt; (append '() '(1))
(1)
&gt; (append '(1 2 (3 4)) '())
(1 2 (3 4))
&gt; (append '(1 2 3) '(4 5 6) '(7 8 9))
(1 2 3 4 5 6 7 8 9)
</pre>

<p>
The resulting list is almost always newly allocated, but it shares structure
with the last argument. If the last argument is not a proper list, then 
applying <tt>append</tt> will result in an improper list:

</p><p>
</p><pre>&gt; (append '(1 2) 'b)
(1 2 . b)
&gt; (append '() 'c)
c
</pre>

<p>
There are also a couple of procedures for finding out whether a given element
can be found in a list, namely <tt>memq</tt>,  <tt>memv</tt> and 
<tt>member</tt>. These are not considered to be predicates, because they
return useful values instead of merely <tt>#t</tt> or <tt>#f</tt>.
The syntax is as follows:
</p><pre>(memq x ls)
(memv x ls)
(member x ls)
</pre>

<p>
The difference between them is that <tt>memq</tt> uses <tt>eq?</tt> to compare,
<tt>memv</tt> uses <tt>eqv?</tt> and <tt>member</tt> uses 
<tt>equal?</tt><a name="tex2html16" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/footnode.html#foot1555"><sup>8.2</sup></a>.
The usage and return values of these procedures can best be described with a
few examples:
</p><pre>&gt; (memq 'a '(a b c))
(a b c)
&gt; (memq 'b '(a b c))
(b c)
&gt; (memv 'a '(a b c))
(a b c)
&gt; (member 'a '(a b c))
(a b c)
&gt; (memq 'a '(b c d))
#f
&gt; (memv 'a '(b c d))
#f
&gt; (member 'a '(b c d))
#f
</pre>

<p>
As we can see, the procedures return the same values for top-level items.
Note that <tt>#f</tt> is returned if the element cannot be found instead of the
empty list!

</p><p>
</p><pre>&gt; (memq '(2 3) '((2 3) 4))
#f
&gt; (memv '(2 3) '((2 3) 4))
#f
&gt; (member '(2 3) '((2 3) 4))
((2 3) 4)
</pre>

<p>
The procedure <tt>member</tt>, which uses <tt>equal?</tt> to compare the
contents of the list, is the only one that returns <tt>#t</tt> because 
<tt>equal?</tt> checks if two objects have the same value (e.g. if two lists
contain the same items) as opposed to <tt>eq?</tt> and <tt>eqv?</tt> that
check if two objects refer to the same place. 

</p><p>
There are also three procedures for finding the first pair with a given car
field in an association list, namely <tt>assq</tt>,
<tt>assv</tt> and <tt>assoc</tt>. They have the following syntax:

</p><p>
</p><pre>(assq x als)
(assv x als)
(assoc x als)
</pre>

<p>
An association list is a list of pairs, for 
example:&nbsp;<tt>((x 10)&nbsp;(y 20)&nbsp;(z 30))</tt>. Let's take a look at a few 
examples:
</p><pre>&gt; (define als '((x 10) (y 20) (x 30)))
&gt; (assq 'a als)
#f
&gt; (assq 'x als)
(x 10)
&gt; (assq 'y als)
(y 20)
&gt; (assv 'x als)
(x 10)
&gt; (assoc 'x als)
(x 10)
&gt; (assoc (list 'x) '(((x)) ((b)) ((c))))
((x))
</pre>

<p>
The difference between <tt>assq</tt>, <tt>assv</tt> and <tt>assoc</tt> is that
<tt>assq</tt> uses <tt>eq?</tt> to compare, <tt>assv</tt> uses <tt>eqv?</tt>
and <tt>assoc</tt> uses <tt>equal?</tt>.

</p><p>
Another extremely useful procedure in Scheme is <tt>map</tt>, which
takes a procedure and an arbitrary number of lists as arguments and
returns a list. If one list is given as an argument, the procedure
will be applied to each element of the list. If two or more lists are
given as arguments, the procedure is applied to each
<i>n</i>th item of each list. The lists must all be of the same length.
The procedure must of course be applicable to the elements in the
list,  otherwise an error will occur. Let's say we want to add one to
each element in the list <tt>(1 2 3 4 5)</tt>. This can be done in the
following way:
</p><pre>&gt; (map (lambda (x) (+ x 1)) '(1 2 3 4 5))
(2 3 4 5 6)
</pre> 

<p>
Let's say that we want to compute the factorial of each element in the list.
The easiest way is to first define a procedure for computing the factorial of
an integer and then feed the procedure to <tt>map</tt> as follows:
</p><pre>(define fact
  (lambda (n)	
    (if (= n 0)
        1
        (* n (fact (- n 1)))))

&gt; (map fact (list 1 2 3 4 5))
(1 2 6 24 120)
</pre> 

<p>
Now we might want to raise the factorial of each element in the list to a
given power. This requires a function taking two arguments. So, how can we
accomplish our task? Let's start by defining a procedure for raising the
factorial of a number to a given power:

</p><pre>(define fact-expt
  (lambda (n e)
    (expt (fact n) e)))
</pre>

<p>
In order to use the procedure we can use <tt>map</tt> and keep the value of
<i>e</i>, the second argument of <tt>fact-expt</tt>, constant in the
following way:

</p><p>
</p><pre>&gt; (map (lambda (x) (fact-expt x 1)) (list 1 2 3 4 5))
(1 2 6 24 120)

&gt; (map (lambda (x) (fact-expt x 2)) (list 1 2 3 4 5))
(1 4 36 576 14400)

&gt; (map (lambda (x) (fact-expt x 3)) (list 1 2 3 4 5))
(1 8 216 13824 1728000)
</pre> 

<p>
Note that <tt>map</tt> only works on the top-level items of a list. 

</p><p>
If two or more lists are given as arguments to map, the procedure will be
applied to each <i>n</i>th element of the lists, e.g:
</p><pre>&gt; (map + '(1 2 3) '(1 2 3))
(2 4 6)
&gt; (map * '(1 2 3) '(1 2 3) '(1 2 3))
(1 8 27)
</pre>

<p>
Another procedure resembling <tt>map</tt> but used only for its side effects
is <tt>for-each</tt>, which has the following syntax:
</p><pre>(for-each proc ls1 ls2 ...)
</pre>

<p>
The difference between <tt>map</tt> and <tt>for-each</tt> is that the latter is
guaranteed to apply the procedure to the elements in the order they appear.
Also note that <tt>map</tt> returns a list, whereas the return value of  
<tt>for-each</tt> is unspecified.
Let's look at a quick example:
</p><pre>&gt; (for-each 
   (lambda (x) 
     (begin 
       (display x) 
       (newline))) 
   '(I am the greatest))
i
am
the
greatest
</pre>

<p>
In fact, <tt>for-each</tt> is commonly used for input and output.

</p><p>
Sometimes we want to apply a procedure to a list using the items of the list
as arguments to the procedure. Scheme has a procedure <tt>apply</tt> for this
purpose. <tt>apply</tt> has the following syntax:
</p><pre>(apply proc arg1 ... args)
</pre>

<p>
The argument <tt>proc</tt> must be a procedure and <i>args</i> must be a 
list. The other arguments may be of any type as long as the procedure given
is applicable. The usage of <tt>apply</tt> is best described with a few 
examples:
</p><pre>&gt;(apply + 1 2 '(3)) 
6
&gt; (apply + '(1 2 3))
6
&gt; (apply - 1 2 3 4 '())
-8
&gt; (apply * (map (lambda (x) (fact x)) '(1 2 3)))
12
</pre>

<p>

</p><h1><a name="SECTION001070000000000000000">
Vectors</a>
</h1>

<p>
Vectors are data types that associate elements with an integer starting from
zero. The difference between vectors and lists are that vectors usually 
occupy less space than the corresponding list and the time required to access a
random element is constant. Most of the procedures operating on lists are
linear in time.

</p><p>
Vectors are represented as #(obj ...), for example:
</p><pre>#((2 4 6 8) 1  "Scheme")
</pre>

<p>
The length of a vector is the number of elements it contains. The length of
the vector above is hence 3.

</p><p>

</p><h2><a name="SECTION001071000000000000000">
Operations on vectors</a>
</h2>

<p>
Scheme provides a predicate <tt>vector?</tt> for determining whether a given
object is a vector or not. For example:
</p><pre>&gt; (vector? '(1 2 3 4))
#f
&gt; (vector? '#(1 2 3 4))
#t
</pre>

<p>
There is a variety of procedures for creating and manipulating vectors. 
Vectors can be created with the procedures <tt>vector</tt> and 
<tt>make-vector</tt>.
The procedure <tt>vector</tt> takes an arbitrary number of arguments and 
returns a newly allocated vector containing the arguments as elements, for
example:
</p><pre>&gt; (vector 'a 'b "foobar" '(1 2 3 4) '#(another vector))
#(a b "foobar" (1 2 3 4) #(another vector))
&gt; (vector)
#()
</pre>

<p>
The procedure <tt>make-vector</tt> has the following syntax:
</p><pre>(make-vector n)
(make-vector n k)
</pre>

<p>
If <i>k</i> is given, a newly allocated vector consisting of <i>n</i>
elements, which all are <i>k</i>, will be returned. Otherwise, the contents
of the vector returned will be unspecified. For example:
</p><pre>&gt; (make-vector 3)
#(0 0 0)
&gt; (make-vector 3 "foobar")
#("foobar" "foobar" "foobar")
</pre>

<p>
The length of the vector is the number of elements in it. Scheme provides a
procedure <tt>vector-length</tt>, which takes a vector as argument and returns
the length of the vector as follows:
</p><pre>&gt; (vector-length '#(a b c d))
4
&gt; (vector-length '#(a b #(a b) '(a b)))
4
&gt; (vector-length '#())
0
</pre>

<p>
To reference an item in the vector, you can use the procedure 
<tt>vector-ref</tt>, which takes a vector and an integer <i>n</i> as
arguments and returns the <i>n</i>:th element in the vector. Note that the
first element is indexed as 0.
</p><pre>&gt; (vector-ref '#(1 2 3 4) 2)
3
&gt; (vector-ref '#(1 2 3 4) 0)
1
</pre>

<p>
Vectors can be converted to lists and vice versa with the procedures
<tt>vector-&gt;list</tt> and <tt>list-&gt;vector</tt>. For example:
</p><pre>&gt; (vector-&gt;list '#(1 2 3 4))
(1 2 3 4)
&gt; (list-&gt;vector '(1 2 3 4))
#(1 2 3 4)
</pre>

<p>
Scheme provides a procedure <tt>vector-set!</tt>, which has the following
syntax:
</p><pre>(vector-set! vec n k)
</pre>

<p>
and stores the object <i>k</i> in index <i>n</i> of the vector 
<i>vec</i>. The return value is unspecified. 

</p><p>
For example:
</p><pre>&gt; (define v (vector 'a 'b 'c 'd))
&gt; (vector-set! v 0 1)
&gt; v
#(1 b c d)
&gt; (vector-set! v 3 '(a list of elements))
&gt; v
#(1 b c (a list of elements))
</pre>

<p>
Note that the procedure <tt>vector-set!</tt> cannot be used on vector 
constants. 

</p><p>
Another procedure causing side effects is <tt>vector-fill!</tt>, which has
the following syntax:
</p><pre>(vector-fill! vec k)
</pre>

<p>
It stores <i>k</i> in every element of <i>vec</i>. The return value is
unspecified. For example:
</p><pre>&gt; (define v (vector 1 2 3 4))
&gt; v
#(1 2 3 4)
&gt; (vector-fill! v '(1 2))
#((1 2) (1 2) (1 2) (1 2))
</pre>

<p>
The procedure  <tt>vector-fill!</tt> cannot be used on vector constants either.

</p><p>
Note that even if the implementation returns something useful, as it did in
our example above, procedures which are used for their side effects (such
as <tt>vector-fill!</tt>) should never be used for the values they might 
return. 

</p><p>
</p><hr>
<!--Navigation Panel-->
<a name="tex2html298" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">
<img width="37" height="24" align="BOTTOM" border="0" alt="next" src="./Data types_files/next.png"></a> 
<a name="tex2html294" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.html">
<img width="26" height="24" align="BOTTOM" border="0" alt="up" src="./Data types_files/up.png"></a> 
<a name="tex2html288" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node9.html">
<img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="./Data types_files/prev.png"></a> 
<a name="tex2html296" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node1.html">
<img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="./Data types_files/contents.png"></a>  
<br>
<b> Next:</b> <a name="tex2html299" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node11.html">Equivalence predicates</a>
<b> Up:</b> <a name="tex2html295" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/schemetutorial.html">Scheme Tutorial</a>
<b> Previous:</b> <a name="tex2html289" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node9.html">Imperative programming</a>
 &nbsp; <b>  <a name="tex2html297" href="http://www.cs.hut.fi/Studies/T-93.210/schemetutorial/node1.html">Contents</a></b> 
<!--End of Navigation Panel-->
<address>
Timo Lilja
2001-09-11
</address>


</body></html>